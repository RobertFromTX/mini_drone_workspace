/*
 * mpu6050_lib.c
 *
 *  Created on: Jul 11, 2025
 *      Author: Robert Chu
 */

#ifndef INC_MPU6050_LIB_H_
#include "mpu6050_lib.h"
#endif /* INC_MPU6050_LIB_H_ */

//private variables
uint8_t i2c_RX_done = 0;
uint8_t i2c_TX_done = 0;
uint8_t data_ready = 0; //accelerometer data ready interrupt

uint8_t receive_buffer[20]; //received message buffer, randomly used

static const unsigned char dmpMemory[MPU6050_DMP_CODE_SIZE] __attribute__((section(".flash"))) = {
	/* bank # 0 */
	0xFB, 0x00, 0x00, 0x3E, 0x00, 0x0B, 0x00, 0x36, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00,
	0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0xFA, 0x80, 0x00, 0x0B, 0x12, 0x82, 0x00, 0x01,
	0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x28, 0x00, 0x00, 0xFF, 0xFF, 0x45, 0x81, 0xFF, 0xFF, 0xFA, 0x72, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x03, 0xE8, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x7F, 0xFF, 0xFF, 0xFE, 0x80, 0x01,
	0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x40, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x02, 0xCB, 0x47, 0xA2, 0x20, 0x00, 0x00, 0x00,
	0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
	0x41, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x2A, 0x00, 0x00, 0x16, 0x55, 0x00, 0x00, 0x21, 0x82,
	0xFD, 0x87, 0x26, 0x50, 0xFD, 0x80, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x05, 0x80, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x6F, 0x00, 0x02, 0x65, 0x32, 0x00, 0x00, 0x5E, 0xC0,
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFB, 0x8C, 0x6F, 0x5D, 0xFD, 0x5D, 0x08, 0xD9, 0x00, 0x7C, 0x73, 0x3B, 0x00, 0x6C, 0x12, 0xCC,
	0x32, 0x00, 0x13, 0x9D, 0x32, 0x00, 0xD0, 0xD6, 0x32, 0x00, 0x08, 0x00, 0x40, 0x00, 0x01, 0xF4,
	0xFF, 0xE6, 0x80, 0x79, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0xD6, 0x00, 0x00, 0x27, 0x10,
	/* bank # 1 */
	0xFB, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xFA, 0x36, 0xFF, 0xBC, 0x30, 0x8E, 0x00, 0x05, 0xFB, 0xF0, 0xFF, 0xD9, 0x5B, 0xC8,
	0xFF, 0xD0, 0x9A, 0xBE, 0x00, 0x00, 0x10, 0xA9, 0xFF, 0xF4, 0x1E, 0xB2, 0x00, 0xCE, 0xBB, 0xF7,
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x02, 0x02, 0x00, 0x00, 0x0C,
	0xFF, 0xC2, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0xCF, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x14,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x09, 0x23, 0xA1, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x03, 0x3F, 0x68, 0xB6, 0x79, 0x35, 0x28, 0xBC, 0xC6, 0x7E, 0xD1, 0x6C,
	0x80, 0x00, 0xFF, 0xFF, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB2, 0x6A, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xF0, 0x00, 0x00, 0x00, 0x30,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00,
	0x00, 0x00, 0x25, 0x4D, 0x00, 0x2F, 0x70, 0x6D, 0x00, 0x00, 0x05, 0xAE, 0x00, 0x0C, 0x02, 0xD0,
	/* bank # 2 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x44, 0x00, 0x01, 0x00, 0x05, 0x8B, 0xC1, 0x00, 0x00, 0x01, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0xFF, 0xEF, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* bank # 3 */
	0xD8, 0xDC, 0xBA, 0xA2, 0xF1, 0xDE, 0xB2, 0xB8, 0xB4, 0xA8, 0x81, 0x91, 0xF7, 0x4A, 0x90, 0x7F,
	0x91, 0x6A, 0xF3, 0xF9, 0xDB, 0xA8, 0xF9, 0xB0, 0xBA, 0xA0, 0x80, 0xF2, 0xCE, 0x81, 0xF3, 0xC2,
	0xF1, 0xC1, 0xF2, 0xC3, 0xF3, 0xCC, 0xA2, 0xB2, 0x80, 0xF1, 0xC6, 0xD8, 0x80, 0xBA, 0xA7, 0xDF,
	0xDF, 0xDF, 0xF2, 0xA7, 0xC3, 0xCB, 0xC5, 0xB6, 0xF0, 0x87, 0xA2, 0x94, 0x24, 0x48, 0x70, 0x3C,
	0x95, 0x40, 0x68, 0x34, 0x58, 0x9B, 0x78, 0xA2, 0xF1, 0x83, 0x92, 0x2D, 0x55, 0x7D, 0xD8, 0xB1,
	0xB4, 0xB8, 0xA1, 0xD0, 0x91, 0x80, 0xF2, 0x70, 0xF3, 0x70, 0xF2, 0x7C, 0x80, 0xA8, 0xF1, 0x01,
	0xB0, 0x98, 0x87, 0xD9, 0x43, 0xD8, 0x86, 0xC9, 0x88, 0xBA, 0xA1, 0xF2, 0x0E, 0xB8, 0x97, 0x80,
	0xF1, 0xA9, 0xDF, 0xDF, 0xDF, 0xAA, 0xDF, 0xDF, 0xDF, 0xF2, 0xAA, 0x4C, 0xCD, 0x6C, 0xA9, 0x0C,
	0xC9, 0x2C, 0x97, 0x97, 0x97, 0x97, 0xF1, 0xA9, 0x89, 0x26, 0x46, 0x66, 0xB0, 0xB4, 0xBA, 0x80,
	0xAC, 0xDE, 0xF2, 0xCA, 0xF1, 0xB2, 0x8C, 0x02, 0xA9, 0xB6, 0x98, 0x00, 0x89, 0x0E, 0x16, 0x1E,
	0xB8, 0xA9, 0xB4, 0x99, 0x2C, 0x54, 0x7C, 0xB0, 0x8A, 0xA8, 0x96, 0x36, 0x56, 0x76, 0xF1, 0xB9,
	0xAF, 0xB4, 0xB0, 0x83, 0xC0, 0xB8, 0xA8, 0x97, 0x11, 0xB1, 0x8F, 0x98, 0xB9, 0xAF, 0xF0, 0x24,
	0x08, 0x44, 0x10, 0x64, 0x18, 0xF1, 0xA3, 0x29, 0x55, 0x7D, 0xAF, 0x83, 0xB5, 0x93, 0xAF, 0xF0,
	0x00, 0x28, 0x50, 0xF1, 0xA3, 0x86, 0x9F, 0x61, 0xA6, 0xDA, 0xDE, 0xDF, 0xD9, 0xFA, 0xA3, 0x86,
	0x96, 0xDB, 0x31, 0xA6, 0xD9, 0xF8, 0xDF, 0xBA, 0xA6, 0x8F, 0xC2, 0xC5, 0xC7, 0xB2, 0x8C, 0xC1,
	0xB8, 0xA2, 0xDF, 0xDF, 0xDF, 0xA3, 0xDF, 0xDF, 0xDF, 0xD8, 0xD8, 0xF1, 0xB8, 0xA8, 0xB2, 0x86,
	/* bank # 4 */
	0xB4, 0x98, 0x0D, 0x35, 0x5D, 0xB8, 0xAA, 0x98, 0xB0, 0x87, 0x2D, 0x35, 0x3D, 0xB2, 0xB6, 0xBA,
	0xAF, 0x8C, 0x96, 0x19, 0x8F, 0x9F, 0xA7, 0x0E, 0x16, 0x1E, 0xB4, 0x9A, 0xB8, 0xAA, 0x87, 0x2C,
	0x54, 0x7C, 0xB9, 0xA3, 0xDE, 0xDF, 0xDF, 0xA3, 0xB1, 0x80, 0xF2, 0xC4, 0xCD, 0xC9, 0xF1, 0xB8,
	0xA9, 0xB4, 0x99, 0x83, 0x0D, 0x35, 0x5D, 0x89, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0xB5, 0x93, 0xA3,
	0x0E, 0x16, 0x1E, 0xA9, 0x2C, 0x54, 0x7C, 0xB8, 0xB4, 0xB0, 0xF1, 0x97, 0x83, 0xA8, 0x11, 0x84,
	0xA5, 0x09, 0x98, 0xA3, 0x83, 0xF0, 0xDA, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xD8, 0xF1, 0xA5,
	0x29, 0x55, 0x7D, 0xA5, 0x85, 0x95, 0x02, 0x1A, 0x2E, 0x3A, 0x56, 0x5A, 0x40, 0x48, 0xF9, 0xF3,
	0xA3, 0xD9, 0xF8, 0xF0, 0x98, 0x83, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0x97, 0x82, 0xA8, 0xF1,
	0x11, 0xF0, 0x98, 0xA2, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xDA, 0xF3, 0xDE, 0xD8, 0x83, 0xA5,
	0x94, 0x01, 0xD9, 0xA3, 0x02, 0xF1, 0xA2, 0xC3, 0xC5, 0xC7, 0xD8, 0xF1, 0x84, 0x92, 0xA2, 0x4D,
	0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
	0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0x93, 0xA3, 0x4D,
	0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
	0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0xA8, 0x8A, 0x9A,
	0xF0, 0x28, 0x50, 0x78, 0x9E, 0xF3, 0x88, 0x18, 0xF1, 0x9F, 0x1D, 0x98, 0xA8, 0xD9, 0x08, 0xD8,
	0xC8, 0x9F, 0x12, 0x9E, 0xF3, 0x15, 0xA8, 0xDA, 0x12, 0x10, 0xD8, 0xF1, 0xAF, 0xC8, 0x97, 0x87,
	/* bank # 5 */
	0x34, 0xB5, 0xB9, 0x94, 0xA4, 0x21, 0xF3, 0xD9, 0x22, 0xD8, 0xF2, 0x2D, 0xF3, 0xD9, 0x2A, 0xD8,
	0xF2, 0x35, 0xF3, 0xD9, 0x32, 0xD8, 0x81, 0xA4, 0x60, 0x60, 0x61, 0xD9, 0x61, 0xD8, 0x6C, 0x68,
	0x69, 0xD9, 0x69, 0xD8, 0x74, 0x70, 0x71, 0xD9, 0x71, 0xD8, 0xB1, 0xA3, 0x84, 0x19, 0x3D, 0x5D,
	0xA3, 0x83, 0x1A, 0x3E, 0x5E, 0x93, 0x10, 0x30, 0x81, 0x10, 0x11, 0xB8, 0xB0, 0xAF, 0x8F, 0x94,
	0xF2, 0xDA, 0x3E, 0xD8, 0xB4, 0x9A, 0xA8, 0x87, 0x29, 0xDA, 0xF8, 0xD8, 0x87, 0x9A, 0x35, 0xDA,
	0xF8, 0xD8, 0x87, 0x9A, 0x3D, 0xDA, 0xF8, 0xD8, 0xB1, 0xB9, 0xA4, 0x98, 0x85, 0x02, 0x2E, 0x56,
	0xA5, 0x81, 0x00, 0x0C, 0x14, 0xA3, 0x97, 0xB0, 0x8A, 0xF1, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9,
	0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x84, 0x0D, 0xDA, 0x0E, 0xD8, 0xA3, 0x29, 0x83, 0xDA,
	0x2C, 0x0E, 0xD8, 0xA3, 0x84, 0x49, 0x83, 0xDA, 0x2C, 0x4C, 0x0E, 0xD8, 0xB8, 0xB0, 0xA8, 0x8A,
	0x9A, 0xF5, 0x20, 0xAA, 0xDA, 0xDF, 0xD8, 0xA8, 0x40, 0xAA, 0xD0, 0xDA, 0xDE, 0xD8, 0xA8, 0x60,
	0xAA, 0xDA, 0xD0, 0xDF, 0xD8, 0xF1, 0x97, 0x86, 0xA8, 0x31, 0x9B, 0x06, 0x99, 0x07, 0xAB, 0x97,
	0x28, 0x88, 0x9B, 0xF0, 0x0C, 0x20, 0x14, 0x40, 0xB8, 0xB0, 0xB4, 0xA8, 0x8C, 0x9C, 0xF0, 0x04,
	0x28, 0x51, 0x79, 0x1D, 0x30, 0x14, 0x38, 0xB2, 0x82, 0xAB, 0xD0, 0x98, 0x2C, 0x50, 0x50, 0x78,
	0x78, 0x9B, 0xF1, 0x1A, 0xB0, 0xF0, 0x8A, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x8B, 0x29, 0x51, 0x79,
	0x8A, 0x24, 0x70, 0x59, 0x8B, 0x20, 0x58, 0x71, 0x8A, 0x44, 0x69, 0x38, 0x8B, 0x39, 0x40, 0x68,
	0x8A, 0x64, 0x48, 0x31, 0x8B, 0x30, 0x49, 0x60, 0xA5, 0x88, 0x20, 0x09, 0x71, 0x58, 0x44, 0x68,
	/* bank # 6 */
	0x11, 0x39, 0x64, 0x49, 0x30, 0x19, 0xF1, 0xAC, 0x00, 0x2C, 0x54, 0x7C, 0xF0, 0x8C, 0xA8, 0x04,
	0x28, 0x50, 0x78, 0xF1, 0x88, 0x97, 0x26, 0xA8, 0x59, 0x98, 0xAC, 0x8C, 0x02, 0x26, 0x46, 0x66,
	0xF0, 0x89, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x24, 0x70, 0x59, 0x44, 0x69, 0x38, 0x64, 0x48, 0x31,
	0xA9, 0x88, 0x09, 0x20, 0x59, 0x70, 0xAB, 0x11, 0x38, 0x40, 0x69, 0xA8, 0x19, 0x31, 0x48, 0x60,
	0x8C, 0xA8, 0x3C, 0x41, 0x5C, 0x20, 0x7C, 0x00, 0xF1, 0x87, 0x98, 0x19, 0x86, 0xA8, 0x6E, 0x76,
	0x7E, 0xA9, 0x99, 0x88, 0x2D, 0x55, 0x7D, 0x9E, 0xB9, 0xA3, 0x8A, 0x22, 0x8A, 0x6E, 0x8A, 0x56,
	0x8A, 0x5E, 0x9F, 0xB1, 0x83, 0x06, 0x26, 0x46, 0x66, 0x0E, 0x2E, 0x4E, 0x6E, 0x9D, 0xB8, 0xAD,
	0x00, 0x2C, 0x54, 0x7C, 0xF2, 0xB1, 0x8C, 0xB4, 0x99, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0x81, 0x91,
	0xAC, 0x38, 0xAD, 0x3A, 0xB5, 0x83, 0x91, 0xAC, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9, 0x48, 0xD8,
	0x6D, 0xD9, 0x68, 0xD8, 0x8C, 0x9D, 0xAE, 0x29, 0xD9, 0x04, 0xAE, 0xD8, 0x51, 0xD9, 0x04, 0xAE,
	0xD8, 0x79, 0xD9, 0x04, 0xD8, 0x81, 0xF3, 0x9D, 0xAD, 0x00, 0x8D, 0xAE, 0x19, 0x81, 0xAD, 0xD9,
	0x01, 0xD8, 0xF2, 0xAE, 0xDA, 0x26, 0xD8, 0x8E, 0x91, 0x29, 0x83, 0xA7, 0xD9, 0xAD, 0xAD, 0xAD,
	0xAD, 0xF3, 0x2A, 0xD8, 0xD8, 0xF1, 0xB0, 0xAC, 0x89, 0x91, 0x3E, 0x5E, 0x76, 0xF3, 0xAC, 0x2E,
	0x2E, 0xF1, 0xB1, 0x8C, 0x5A, 0x9C, 0xAC, 0x2C, 0x28, 0x28, 0x28, 0x9C, 0xAC, 0x30, 0x18, 0xA8,
	0x98, 0x81, 0x28, 0x34, 0x3C, 0x97, 0x24, 0xA7, 0x28, 0x34, 0x3C, 0x9C, 0x24, 0xF2, 0xB0, 0x89,
	0xAC, 0x91, 0x2C, 0x4C, 0x6C, 0x8A, 0x9B, 0x2D, 0xD9, 0xD8, 0xD8, 0x51, 0xD9, 0xD8, 0xD8, 0x79,
	/* bank # 7 */
	0xD9, 0xD8, 0xD8, 0xF1, 0x9E, 0x88, 0xA3, 0x31, 0xDA, 0xD8, 0xD8, 0x91, 0x2D, 0xD9, 0x28, 0xD8,
	0x4D, 0xD9, 0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x83, 0x93, 0x35, 0x3D, 0x80, 0x25, 0xDA,
	0xD8, 0xD8, 0x85, 0x69, 0xDA, 0xD8, 0xD8, 0xB4, 0x93, 0x81, 0xA3, 0x28, 0x34, 0x3C, 0xF3, 0xAB,
	0x8B, 0xF8, 0xA3, 0x91, 0xB6, 0x09, 0xB4, 0xD9, 0xAB, 0xDE, 0xFA, 0xB0, 0x87, 0x9C, 0xB9, 0xA3,
	0xDD, 0xF1, 0x20, 0x28, 0x30, 0x38, 0x9A, 0xF1, 0x28, 0x30, 0x38, 0x9D, 0xF1, 0xA3, 0xA3, 0xA3,
	0xA3, 0xF2, 0xA3, 0xB4, 0x90, 0x80, 0xF2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3,
	0xA3, 0xB2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xB0, 0x87, 0xB5, 0x99, 0xF1, 0x28, 0x30, 0x38,
	0x98, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x97, 0xA3, 0xA3, 0xA3, 0xA3, 0xF3, 0x9B, 0xA3, 0x30, 0xDC,
	0xB9, 0xA7, 0xF1, 0x26, 0x26, 0x26, 0xFE, 0xD8, 0xFF,

};

#ifndef MPU6050_DMP_FIFO_RATE_DIVISOR
#define MPU6050_DMP_FIFO_RATE_DIVISOR 0x01 // The New instance of the Firmware has this as the default
#endif

//pData is buffer to put read contents into, len is bytes to read from mpu6050
HAL_StatusTypeDef i2c_Read_Accelerometer(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t regAddress, uint8_t *pData, uint16_t len)
{
	HAL_StatusTypeDef returnValue;
	uint8_t reg_addr[1];

	/* We compute the MSB and LSB parts of the memory address */
	reg_addr[0] = (uint8_t) (regAddress);

	while (HAL_I2C_GetState(hi2c) != HAL_I2C_STATE_READY);
	/* First we send the memory location address where start reading data */
	returnValue = HAL_I2C_Master_Seq_Transmit_DMA(hi2c, DevAddress, reg_addr, 1, I2C_FIRST_FRAME);
	//	while (!i2c_TX_done);
	//	i2c_TX_done = 0;
	while (HAL_I2C_GetState(hi2c) != HAL_I2C_STATE_READY);
	/* Next we can retrieve the data from EEPROM */
	returnValue = HAL_I2C_Master_Seq_Receive_DMA(hi2c, DevAddress, pData, len, I2C_LAST_FRAME);	//get data we requested and place it in pData buffer
	while (!i2c_RX_done);
	i2c_RX_done = 0;

	//for some reason after doing the receive function, the I2C2's CR1 (control register 1) goes from 0x401 to 0x201. This then causes issues
	//when trying to do the next transmit. As a result, I'm manually making sure the correct bits are turned on and off.
	//This seems to only be an issue on the STM32F103C8T6
	hi2c->Instance->CR1 &= ~I2C_CR1_STOP;	//make sure stop bit is turned off (bit 9)
	hi2c->Instance->CR1 |= I2C_CR1_ACK;	//turn on acknowledge bit (bit 10)
	return returnValue;
}

HAL_StatusTypeDef i2c_Write_Accelerometer(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t regAddress, uint8_t *pData, uint16_t len)
{
	HAL_StatusTypeDef returnValue;
	uint8_t *data;

	data = (uint8_t*) malloc(sizeof(uint8_t) * (1 + len));
	/*We compute the MSB and LSB parts of the memory address*/
	data[0] = (uint8_t) (regAddress);

	/*And copy the content of the pData array in the temporary buffer*/
	memcpy(data + 1, pData, len);	//inserts data one slot after the register address

	/*We are now ready to transfer the buffer over the I2C bus*/
	returnValue = HAL_I2C_Master_Transmit_DMA(hi2c, DevAddress, data, len + 1);
	while (!i2c_TX_done);
	i2c_TX_done = 0;
	free(data);
	/*We wait until the Accelerometer effectively stores data*/
	while (HAL_I2C_IsDeviceReady(hi2c, DevAddress, 1, HAL_MAX_DELAY) != HAL_OK);	//peripheral can only accept the transmission once it finishes doing what it does

	return HAL_OK;
}
HAL_StatusTypeDef setBit(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t regAddress, uint8_t bitNum, uint8_t data)
{
	uint8_t buffer;
	i2c_Read_Accelerometer(hi2c, DevAddress, regAddress, &buffer, 1);
	buffer = (data != 0) ? (buffer | (1 << bitNum)) : (buffer & ~(1 << bitNum));	//bit mask to only change one bit of the register
	return i2c_Write_Accelerometer(hi2c, DevAddress, regAddress, &buffer, 1);	//write the updated register
}
HAL_StatusTypeDef setBits(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t regAddress, uint8_t bitStart, uint8_t length, uint8_t data)
{
	//Set multiple bits as opposed to just 1
	//Example
    //      010 value to write
    // 76543210 bit numbers
    //    xxx   args: bitStart=4, length=3
    // 00011100 mask byte
    // 10101111 original value (sample)
    // 10100011 original & ~mask
    // 10101011 masked | value
    uint8_t buffer;
    i2c_Read_Accelerometer(hi2c, DevAddress, regAddress, &buffer, 1);
	uint8_t mask = ((1 << length) - 1) << (bitStart - length + 1);
	data <<= (bitStart - length + 1); // shift data into correct position
	data &= mask; // zero all non-important bits in data
	buffer &= ~(mask); // zero all important bits in existing byte
	buffer |= data; // combine data with existing byte
	return i2c_Write_Accelerometer(hi2c, DevAddress, regAddress, &buffer, 1);	//write the updated register

}
void mpu6050_init(I2C_HandleTypeDef *hi2c)	//NOT for use with digital motion processor
{
	uint8_t command = 0x00;
	i2c_Write_Accelerometer(hi2c, MPU6050_ADDR_LSL1, 0x6B, &command, 1);	//turn off sleep mode
	//using FIFO to do burst reads on gyroscope and accelerometer

	//to check the returned value of the read, you must either use the debugger and check receive_buffer contents after this line runs, or use oscilloscope/logic analyzer
	i2c_Read_Accelerometer(hi2c, MPU6050_ADDR_LSL1, 0x6B, (uint8_t*) receive_buffer, 1);	//PWR_MGMT_1, check if device is asleep, if you see 0x40, it is asleep and every register reads 0

	//Adjust Sample Rate
	i2c_Read_Accelerometer(hi2c, MPU6050_ADDR_LSL1, 0x1A, (uint8_t*) receive_buffer, 1);	//check digital low pass filter settings, Gyroscope Output Rate = 8kHz when the DLPF is disabled (DLPF_CFG = 0 or 7), and 1kHz when the DLPF is enabled
	i2c_Read_Accelerometer(hi2c, MPU6050_ADDR_LSL1, 0x19, (uint8_t*) receive_buffer, 1);	//check sample rate divider contents
	command = 0x1F;	//divide by sample rate divider + 1
	i2c_Write_Accelerometer(hi2c, MPU6050_ADDR_LSL1, 0x19, (uint8_t*) &command, 1);	// adjust sample rate divider
	i2c_Read_Accelerometer(hi2c, MPU6050_ADDR_LSL1, 0x19, (uint8_t*) receive_buffer, 1);	//check sample rate divider contents

	//initialize/enable FIFO
	command = 0x78;	//0b01111000
	i2c_Write_Accelerometer(hi2c, MPU6050_ADDR_LSL1, 0x23, &command, 1);	//only enable the gyroscope and accelerometer to be in the FIFO
	i2c_Read_Accelerometer(hi2c, MPU6050_ADDR_LSL1, 0x23, (uint8_t*) receive_buffer, 1);	//FIFO_EN contents

	command = 0x00;
	i2c_Write_Accelerometer(hi2c, MPU6050_ADDR_LSL1, 0x6A, (uint8_t*) &command, 1);	//disable FIFO in USER_CTRL register
	i2c_Read_Accelerometer(hi2c, MPU6050_ADDR_LSL1, 0x6A, (uint8_t*) receive_buffer, 1);	//check USER_CTRL contents, should be 0x00

	command = 0x04;
	i2c_Write_Accelerometer(hi2c, MPU6050_ADDR_LSL1, 0x6A, (uint8_t*) &command, 1);	// reset FIFO, must do it when FIFO_EN is off
	i2c_Read_Accelerometer(hi2c, MPU6050_ADDR_LSL1, 0x6A, (uint8_t*) receive_buffer, 1);	//check USER_CTRL contents, should be 0x00 still

	i2c_Read_Accelerometer(hi2c, MPU6050_ADDR_LSL1, 0x72, (uint8_t*) receive_buffer, 2);	//count items in FIFO

	command = 0x40;
	i2c_Write_Accelerometer(hi2c, MPU6050_ADDR_LSL1, 0x6A, (uint8_t*) &command, 1);	//enable FIFO in USER_CTRL register
	i2c_Read_Accelerometer(hi2c, MPU6050_ADDR_LSL1, 0x6A, (uint8_t*) receive_buffer, 1);	//USER_CTRL should be 0x40 now
	i2c_Read_Accelerometer(hi2c, MPU6050_ADDR_LSL1, 0x72, (uint8_t*) receive_buffer, 2);	//count items in FIFO

	//enable data ready interrupt
	command = 0x11;
	i2c_Write_Accelerometer(hi2c, MPU6050_ADDR_LSL1, 0x38, &command, 1);	//enable fifo overflow and data ready interrupt
	i2c_Read_Accelerometer(hi2c, MPU6050_ADDR_LSL1, 0x38, (uint8_t*) receive_buffer, 1);	//check INT_ENABLE contents default is 0x00 I believe

	i2c_Read_Accelerometer(hi2c, MPU6050_ADDR_LSL1, 0x3A, (uint8_t*) receive_buffer, 1);	//check which interrupt request happened (most important is LSB, DATA_READY_INT)
	i2c_Read_Accelerometer(hi2c, MPU6050_ADDR_LSL1, 0x3A, (uint8_t*) receive_buffer, 1);

	//check if interrupt is open drain or push pull via INT_OPEN setting
	i2c_Read_Accelerometer(hi2c, MPU6050_ADDR_LSL1, 0x37, (uint8_t*) receive_buffer, 1);	//be default it is 0, push-pull, no pullup and no pulldown needed

	//Gyro Config
	i2c_Read_Accelerometer(hi2c, MPU6050_ADDR_LSL1, 0x1B, (uint8_t*) receive_buffer, 1);	//read GYRO_CONFIG
	command = 0x10;
	i2c_Write_Accelerometer(hi2c, MPU6050_ADDR_LSL1, 0x1B, &command, 1);	// +/- 1000 degrees/second full range, each 32.8 counts is 1 degree/second, all selftest off
	i2c_Read_Accelerometer(hi2c, MPU6050_ADDR_LSL1, 0x1B, (uint8_t*) receive_buffer, 1);	//read GYRO_CONFIG
	//Accelerometer Config
	i2c_Read_Accelerometer(hi2c, MPU6050_ADDR_LSL1, 0x1C, (uint8_t*) receive_buffer, 1);	//read ACCEL_CONFIG
	command = 0x10;
	i2c_Write_Accelerometer(hi2c, MPU6050_ADDR_LSL1, 0x1C, &command, 1);	// +/- 8g, every 4096 counts is 1g, all self test off
	i2c_Read_Accelerometer(hi2c, MPU6050_ADDR_LSL1, 0x1C, (uint8_t*) receive_buffer, 1);	//read ACCEL_CONFIG
}

void mpu6050_get_raw_measurements(I2C_HandleTypeDef *hi2c, mpu6050_sensor_data *sensor_data)
{
	//get raw data from mpu6050 with i2c interface
	//read without FIFO, IMPORTANT: if using interrupt to synchronize, need a series resistor between interrupt pin on sensor and EXTI pin. Helps to form low pass filter to dampen voltage spikes that mess up the i2c bus and probably more importantly decrease current that could drive SDA pin low.
	i2c_Read_Accelerometer(hi2c, MPU6050_ADDR_LSL1, 0x3B, (uint8_t*) sensor_data->accel_x_buf, 2);	//ACCEL_XOUT, 2 bytes
	i2c_Read_Accelerometer(hi2c, MPU6050_ADDR_LSL1, 0x3D, (uint8_t*) sensor_data->accel_y_buf, 2);	//ACCEL_YOUT, 2 bytes
	i2c_Read_Accelerometer(hi2c, MPU6050_ADDR_LSL1, 0x3F, (uint8_t*) sensor_data->accel_z_buf, 2);	//ACCEL_ZOUT, 2 bytes
	i2c_Read_Accelerometer(hi2c, MPU6050_ADDR_LSL1, 0x43, (uint8_t*) sensor_data->gyro_x_buf, 2);	//GYRO_XOUT, 2 bytes
	i2c_Read_Accelerometer(hi2c, MPU6050_ADDR_LSL1, 0x45, (uint8_t*) sensor_data->gyro_y_buf, 2);	//GYRO_YOUT, 2 bytes
	i2c_Read_Accelerometer(hi2c, MPU6050_ADDR_LSL1, 0x47, (uint8_t*) sensor_data->gyro_z_buf, 2);	//GYRO_ZOUT, 2 bytes
	sensor_data->accel_x = (sensor_data->accel_x_buf[0] << 8) | sensor_data->accel_x_buf[1];
	sensor_data->accel_y = (sensor_data->accel_y_buf[0] << 8) | sensor_data->accel_y_buf[1];
	sensor_data->accel_z = (sensor_data->accel_z_buf[0] << 8) | sensor_data->accel_z_buf[1];
	sensor_data->gyro_x = (sensor_data->gyro_x_buf[0] << 8) | sensor_data->gyro_x_buf[1];
	sensor_data->gyro_y = (sensor_data->gyro_y_buf[0] << 8) | sensor_data->gyro_y_buf[1];
	sensor_data->gyro_z = (sensor_data->gyro_z_buf[0] << 8) | sensor_data->gyro_z_buf[1];
}

void sensor_data_init(mpu6050_sensor_data *sensor_data)
{
	//initialize values that will be calculated later anyways, probably not necessary to do
	sensor_data->yaw = 0;
	sensor_data->pitch = 0;
	sensor_data->roll = 0;
}

//MPU6050 code with DMP, credits: https://github.com/jrowberg/i2cdevlib/blob/master/Arduino/MPU6050/MPU6050_6Axis_MotionApps20.cpp#L272, MPU6050_6Axis_MotionApps20::dmpInitialize()
//code was built for arduino, so I'm porting it to stm32
void mpu6050_init_dmp(I2C_HandleTypeDef *hi2c)
{
	//reset the MPU6050
	setBit(hi2c, MPU6050_ADDR_LSL1, 0x6B, 7, 1);	//Device reset bit: When set to 1, this bit resets all internal registers to their default values.  The bit automatically clears to 0 once the reset is done.
	HAL_Delay(30); //wait a little

	//turn off sleep mode, FIXME might want to implement with setBit in the future
	uint8_t command = 0x00;
	i2c_Write_Accelerometer(hi2c, MPU6050_ADDR_LSL1, 0x6B, &command, 1);

	// get MPU hardware revision
	setMemoryBank(hi2c, 0x10, 1, 1); //memory bank 2, prefetch enabled, userbank enabled
	setMemoryStartAddress(hi2c, 0x06);
	//DEBUG_PRINTLN(F("Checking hardware revision..."));
	//DEBUG_PRINT(F("Revision @ user[16][6] = "));
	//DEBUG_PRINTLN(readMemoryByte());
	uint8_t temp_buf = 0;
	i2c_Read_Accelerometer(hi2c, MPU6050_ADDR_LSL1, MPU6050_RA_MEM_R_W, &temp_buf, 1); //read contents in MPU6050_RA_MEM_R_W register
	//DEBUG_PRINTLN(F("Resetting memory bank selection to 0..."));
	setMemoryBank(hi2c, 0, 0, 0); //memory bank 0, prefetch disabled, userbank disabled

	// check OTP bank valid, want temp_OTP_valid to be 1
	uint8_t temp_OTP_valid = 0;
	temp_OTP_valid = getOTPBankValid(hi2c);

//	// setup weird slave stuff (?)
//	DEBUG_PRINTLN(F("Setting slave 0 address to 0x7F..."));
//	setSlaveAddress(0, 0x7F);
//	DEBUG_PRINTLN(F("Disabling I2C Master mode..."));
//	setI2CMasterModeEnabled(false);
//	DEBUG_PRINTLN(F("Setting slave 0 address to 0x68 (self)..."));
//	setSlaveAddress(0, 0x68);
//	DEBUG_PRINTLN(F("Resetting I2C Master control..."));
//	resetI2CMaster();
//	delay(20);
//	DEBUG_PRINTLN(F("Setting clock source to Z Gyro..."));
//	setClockSource(MPU6050_CLOCK_PLL_ZGYRO);

	//Setting DMP and FIFO_OFLOW interrupts enabled
	setIntEnabled(hi2c, 1<<MPU6050_INTERRUPT_FIFO_OFLOW_BIT|1<<MPU6050_INTERRUPT_DMP_INT_BIT); 	// 1<<4 | 1 << 1

	//Setting sample rate to 200Hz, since we are using DLPF, 1KHz/(4+1) = 200Hz
	command = 0x04;	//divide by sample rate divider + 1
	i2c_Write_Accelerometer(hi2c, MPU6050_ADDR_LSL1, MPU6050_RA_SMPLRT_DIV, (uint8_t*) &command, 1);	// adjust sample rate divider
	i2c_Read_Accelerometer(hi2c, MPU6050_ADDR_LSL1, MPU6050_RA_SMPLRT_DIV, (uint8_t*) receive_buffer, 1);	//check sample rate divider contents

	//skipping fsync
//	DEBUG_PRINTLN(F("Setting external frame sync to TEMP_OUT_L[0]..."));
//	setExternalFrameSync(MPU6050_EXT_SYNC_TEMP_OUT_L);

	//Setting DLPF bandwidth to 42Hz
	setBits(hi2c, MPU6050_ADDR_LSL1, MPU6050_RA_CONFIG, MPU6050_CFG_DLPF_CFG_BIT, MPU6050_CFG_DLPF_CFG_LENGTH, MPU6050_DLPF_BW_42);

	//Setting gyro sensitivity to +/- 1000 deg/sec
	setBits(hi2c, MPU6050_ADDR_LSL1, MPU6050_RA_GYRO_CONFIG, MPU6050_GCONFIG_FS_SEL_BIT, MPU6050_GCONFIG_FS_SEL_LENGTH, MPU6050_GYRO_FS_1000);

	// load DMP code into memory banks
	//DEBUG_PRINT(F("Writing DMP code to MPU memory banks ("));
	//DEBUG_PRINT(MPU6050_DMP_CODE_SIZE);
	//DEBUG_PRINTLN(F(" bytes)"));
	if (!writeProgMemoryBlock(hi2c, dmpMemory, MPU6050_DMP_CODE_SIZE, 0, 0, true)) return 1; // Failed
	//DEBUG_PRINTLN(F("Success! DMP code written and verified."));

	// Set the FIFO Rate Divisor int the DMP Firmware Memory
	unsigned char dmpUpdate[] = {0x00, MPU6050_DMP_FIFO_RATE_DIVISOR};
	writeMemoryBlock(hi2c, dmpUpdate, 0x02, 0x02, 0x16, true, false); // Lets write the dmpUpdate data to the Firmware image, we have 2 bytes to write in bank 0x02 with the Offset 0x16

	//write start address MSB into register
	uint8_t config = 0x03;
	i2c_Write_Accelerometer(hi2c, MPU6050_ADDR_LSL1, MPU6050_RA_DMP_CFG_1, (uint8_t*) &config, 1); //setDMPConfig1(0x03);

	//write start address LSB into register
	config = 0x00;
	i2c_Write_Accelerometer(hi2c, MPU6050_ADDR_LSL1, MPU6050_RA_DMP_CFG_2, (uint8_t*) &config, 1); //	setDMPConfig2(0x00);

	//	DEBUG_PRINTLN(F("Clearing OTP Bank flag..."));
	setBit(hi2c, MPU6050_ADDR_LSL1, MPU6050_RA_XG_OFFS_TC, MPU6050_TC_OTP_BNK_VLD_BIT, false); //	setOTPBankValid(false);


	//DEBUG_PRINTLN(F("Setting motion detection threshold to 2..."));
	uint8_t threshold = 2;
	i2c_Write_Accelerometer(hi2c, MPU6050_ADDR_LSL1, MPU6050_RA_MOT_THR, (uint8_t*) &threshold, 1); //setMotionDetectionThreshold(2);


	//	DEBUG_PRINTLN(F("Setting zero-motion detection threshold to 156..."));
	threshold = 156;
	i2c_Write_Accelerometer(hi2c, MPU6050_ADDR_LSL1, MPU6050_RA_ZRMOT_THR, (uint8_t*) &threshold, 1); //	setZeroMotionDetectionThreshold(156);

	//	DEBUG_PRINTLN(F("Setting motion detection duration to 80..."));
	uint8_t duration = 80;
	i2c_Write_Accelerometer(hi2c, MPU6050_ADDR_LSL1, MPU6050_RA_MOT_DUR, (uint8_t*) &duration, 1); //	setMotionDetectionDuration(80);

	//	DEBUG_PRINTLN(F("Setting zero-motion detection duration to 0..."));
	uint8_t duration = 0;
	i2c_Write_Accelerometer(hi2c, MPU6050_ADDR_LSL1, MPU6050_RA_ZRMOT_DUR, (uint8_t*) &duration, 1); //	setZeroMotionDetectionDuration(0);

	//	DEBUG_PRINTLN(F("Enabling FIFO..."));
	setBit(hi2c, MPU6050_ADDR_LSL1, L3G4200D_RA_CTRL_REG5, L3G4200D_FIFO_EN_BIT, true);//	setFIFOEnabled(true);


	//	DEBUG_PRINTLN(F("Resetting DMP..."));
	setBit(hi2c, MPU6050_ADDR_LSL1, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_DMP_RESET_BIT, true);
	//	resetDMP();
//
//	DEBUG_PRINTLN(F("DMP is good to go! Finally."));
//
//	DEBUG_PRINTLN(F("Disabling DMP (you turn it on later)..."));
//	setDMPEnabled(false);
//
//	DEBUG_PRINTLN(F("Setting up internal 42-byte (default) DMP packet buffer..."));
//	dmpPacketSize = 42;
//
//	DEBUG_PRINTLN(F("Resetting FIFO and clearing INT status one last time..."));
//	resetFIFO();
//	getIntStatus();
}

void setMemoryBank(I2C_HandleTypeDef *hi2c, uint8_t bank, uint8_t prefetchEnabled, uint8_t userBank) {
    bank &= 0x1F;
    if (userBank) bank |= 0x20;
    if (prefetchEnabled) bank |= 0x40;
    i2c_Write_Accelerometer(hi2c, MPU6050_ADDR_LSL1, MPU6050_RA_BANK_SEL, &bank, 1); //write to BANK_SEL = 0x6D register (not in register map documentation)

}
void setMemoryStartAddress(I2C_HandleTypeDef *hi2c, uint8_t address)
{
	i2c_Write_Accelerometer(hi2c, MPU6050_ADDR_LSL1, MPU6050_RA_MEM_START_ADDR, &address, 1); //MPU6050_RA_MEM_START_ADDR = 0x6E, write the start address to this register
}
uint8_t getOTPBankValid(I2C_HandleTypeDef *hi2c) {
	uint8_t temp_buf = 0; //bit 0 is MPU6050_TC_OTP_BNK_VLD_BIT, which is what we need to confirm if OTP bank is valid
	i2c_Read_Accelerometer(hi2c, MPU6050_ADDR_LSL1, MPU6050_RA_XG_OFFS_TC, &temp_buf, 1); //MPU6050_RA_XG_OFFS_TC = 0x00

    return temp_buf;
}
void setIntEnabled(I2C_HandleTypeDef *hi2c, uint8_t enabled) { //call this function to choose which interrupts are enabled
	i2c_Write_Accelerometer(hi2c, MPU6050_ADDR_LSL1, MPU6050_RA_INT_ENABLE, &enabled, 1);
}
bool writeMemoryBlock(I2C_HandleTypeDef *hi2c, const uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t address, bool verify, bool useProgMem) {
    setMemoryBank(hi2c, bank, 0, 0);
    setMemoryStartAddress(hi2c, address);
    uint8_t chunkSize;
    uint8_t *verifyBuffer=0;
    uint8_t *progBuffer=0;
    uint16_t i;
    uint8_t j;
    if (verify) verifyBuffer = (uint8_t *)malloc(MPU6050_DMP_MEMORY_CHUNK_SIZE);
    if (useProgMem) progBuffer = (uint8_t *)malloc(MPU6050_DMP_MEMORY_CHUNK_SIZE);
    for (i = 0; i < dataSize;) {
        // determine correct chunk size according to bank position and data size
        chunkSize = MPU6050_DMP_MEMORY_CHUNK_SIZE;

        // make sure we don't go past the data size
        if (i + chunkSize > dataSize) chunkSize = dataSize - i;

        // make sure this chunk doesn't go past the bank boundary (256 bytes)
        if (chunkSize > 256 - address) chunkSize = 256 - address;

        if (useProgMem) {
            // write the chunk of data as specified
            for (j = 0; j < chunkSize; j++) progBuffer[j] = pgm_read_byte(data + i + j);
        } else {
            // write the chunk of data as specified
            progBuffer = (uint8_t *)data + i;
        }

        ////////////I2Cdev::writeBytes(devAddr, MPU6050_RA_MEM_R_W, chunkSize, progBuffer, wireObj);

        // verify data if needed
        if (verify && verifyBuffer) {
            setMemoryBank(hi2c, bank, 0, 0);
            setMemoryStartAddress(hi2c, address);
            ////////I2Cdev::readBytes(devAddr, MPU6050_RA_MEM_R_W, chunkSize, verifyBuffer, I2Cdev::readTimeout, wireObj);
            if (memcmp(progBuffer, verifyBuffer, chunkSize) != 0) {
                /*Serial.print("Block write verification error, bank ");
                Serial.print(bank, DEC);
                Serial.print(", address ");
                Serial.print(address, DEC);
                Serial.print("!\nExpected:");
                for (j = 0; j < chunkSize; j++) {
                    Serial.print(" 0x");
                    if (progBuffer[j] < 16) Serial.print("0");
                    Serial.print(progBuffer[j], HEX);
                }
                Serial.print("\nReceived:");
                for (uint8_t j = 0; j < chunkSize; j++) {
                    Serial.print(" 0x");
                    if (verifyBuffer[i + j] < 16) Serial.print("0");
                    Serial.print(verifyBuffer[i + j], HEX);
                }
                Serial.print("\n");*/
                free(verifyBuffer);
                if (useProgMem) free(progBuffer);
                return false; // uh oh.
            }
        }

        // increase byte index by [chunkSize]
        i += chunkSize;

        // uint8_t automatically wraps to 0 at 256
        address += chunkSize;

        // if we aren't done, update bank (if necessary) and address
        if (i < dataSize) {
            if (address == 0) bank++;
            setMemoryBank(hi2c, bank,0, 0);
            setMemoryStartAddress(hi2c, address);
        }
    }
    if (verify) free(verifyBuffer);
    if (useProgMem) free(progBuffer);
    return true;
}

bool writeProgMemoryBlock(I2C_HandleTypeDef *hi2c, const uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t address, bool verify) {
    return writeMemoryBlock(hi2c, data, dataSize, bank, address, verify, true);
}
